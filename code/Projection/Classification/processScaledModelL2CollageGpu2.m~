function [ outImg,outLoc ] = processScaledModelL2CollageGpu2(collage,predLocation,patchDim,modelType,dirPath,modelpath)
    %% INIT 1.0
    gpu=0             
    noOflocation=size(predLocation,1);
    %% Cropping the image at mutliple location
    % Divinding collages Parts into different parts. Because RAM & GPU
    % memory will not sufficient to process the full collage at a time.    
    processParallelPatch=600;
    noOfParts=2;       
    [locationCell]=divideInsection(predLocation,collage,noOfParts);
    %% Predict
    [outImg,outLoc]=predictUsingGPU(collageCell,locationCell.patchDim,modelType,dirPath,modelpath,gpu);            

end
function [outImg,outputLoc]=predictUsingGPU(collage,locationCell,patchDim,modelType,dirPath,modelpath,gpu)    
    %% Init 1.0
    [H,W]=size(collage);     
    noOfParts=size(locationCell,1);
    outImg=zeros(H,W);
    outputLoc=[];
    %% SVM    
    if modelType==ModelType.CompactSVM
        fprintf('Loading PCA coefficent....');
        svm_pcaCoeff=dlmread(strcat(dirPath,'/pca_coeff.txt'));
        svm_pcamu=load(strcat(dirPath,'/data_mean.txt'));   
        struct=load(strcat(modelpath,'/compactSVMModel.mat'));
        trainedModel=struct.compactSVMModel;  
        modelType=ModelType.CompactSVM;
        fprintf('Done ..\n');
    end
    %% Gpu
    if gpu ==1 
        fprintf('Gpu: init...');
        if modelType==ModelType.CompactSVM    
            svm_pcaCoeff=gpuArray(svm_pcaCoeff);
            svm_pcamu=gpuArray(svm_pcamu);
        end
        collage=gpuArray(collage);
        fprintf('Done \n');    
    end
    %% Per Patch methods
    function [ feature ] = perPatchMethod(cellCol)   
         vector=cellCol{1};   
         feature=bsxfun(@minus,vector,svm_pcamu)*svm_pcaCoeff;  
         clear vector;
         feature=gather(feature);
    end
    
    %% Process on each part of collage
    for section=1:noOfParts
        fprintf('............[%d/%d].........\n',section,noOfParts);
        location=locationCell{section};    
        resLoc=zeros(size(location,1),3);
        %% Creating Cell Array array
        tic
        fprintf('Creating Cell Array array...\n');
        cellColl=getCroppedImgMtx(collage,location,patchDim);
        fprintf('No Of Location:%d \nEach of Dim:%dx%d',size(colmat,1),patchDim(1),patchDim(2));
        fprintf('Done...\n');
        toc
        %% Processing
        tic
        fprintf('Processing...');
        b=arrayfun(@perPatchMethod,cellColl,'UniformOutput',false);
        fprintf('Done...\n');
        toc
        fprintf('Finding Prediction...');
        tic
        n=size(b,1);
        output=zeros(size(cellColl,2),1);  
        clear cellColl;   
        parfor i=1:n               
            feature=b{i};
            [~,positiveScore] = perdictLabel(modelType,trainedModel,feature);            
            output(i)=[x,y,positiveScore];             
        end
        toc        
        %%  Marking score on Image Managing New location
        for i=1:size(location,1)
            x=location(i,1);y=location(i,2);
            outImg(x,y)=output;
        end
        outputLoc=vertcat(outputLoc,resLoc);
   end        

end


%% DivideInSection

% Divide location in Section for memory 
function [croppedLocCell]=divideInSection(location,collage,noOfParts)
    noOfLocation=size(location,1);
    sectionSize=floor(noOfLocation/2);    
    croppedLocCell=cell(noOfParts,1);
    for i=1:noOfParts
        offset=(i-1)*sectionSize;
        x1=offset;
        x2=offset+sectionSize;
        if x1 < 1
            x1=1;
        end        
        if x2 > noOfLocation
            x2=noOfLocation;
        end
        croppedLocCell{i}=location(x1:x2,:);
    end
end

% Returns the cropped patch at passes "location" point as cell
function [cropCol]=getCroppedImgMtx(collage,location,patchDim)
    [H,W]=size(collage); 
    patchH=patchDim(1);patchW=patchDim(2);   
    noOfLocation=size(location,1);
    cropCol=cell(noOfLocation,1);
    for i=1:noOfLocation
      cx=location(i,1);cy=location(i,2);
      [x1,x2,y1,y2] = getPatchCoordinat(cx,cy,patchDim);
      if (x1<0 || x2>H || y1 <0 || y2 > W)
        continue;
      end
      patch=collage(x1:x2,y1:y2);
      cropCol{i} = reshape(patch,1,patchH*patchW);
    end
end